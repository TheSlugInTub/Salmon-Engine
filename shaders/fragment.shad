#version 330 core
out vec4 FragColor;

in vec2 TexCoords;
in vec3 FragPos;
in vec3 Normal;

uniform sampler2D texture_diffuse;
uniform samplerCube depthMap;
uniform float farPlane;

struct Light 
{
    vec3 pos;
    vec4 color;
    float intensity;
    float radius;
    bool on;
};

const int MAX_LIGHTS = 10;
uniform Light lights[MAX_LIGHTS];

// Pseudo-random number generator between min and max
float random(float min, float max, vec2 seed) {
    // Generate a pseudo-random number using the seed
    float rnd = fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453);
    
    // Scale and shift the random value to the desired range [min, max]
    return min + rnd * (max - min);
}

float ShadowCalculation(vec3 fragPos, int lightIndex)
{
    // get vector between fragment position and light position
    vec3 fragToLight = fragPos - lights[lightIndex].pos;
    // use the light to fragment vector to sample from the depth map    
    float closestDepth = texture(depthMap, fragToLight).r;
    // it is currently in linear range between [0,1]. Re-transform back to original value
    closestDepth *= farPlane;
    // now get current linear depth as the length between the fragment and light position
    float currentDepth = length(fragToLight);
    // now test for shadows
    float bias = 0.5; 
    float shadow = currentDepth -  bias > closestDepth ? 1.0 : 0.0;

    return shadow;
}

void main()
{    
    // Base texture color
    vec4 texColor = texture(texture_diffuse, TexCoords);
    
    // Shadow factor starts at 1.0 (fully lit)
    float shadowFactor = 1.0;

    // Accumulate shadows from all lights
    for (int i = 0; i < lights.length(); ++i) {
        if (lights[i].on == true) {
            float shadow = ShadowCalculation(FragPos, i);
            shadowFactor *= (1.0 - shadow * 0.5); // 0.5 is the darkness factor
        }
    }

    // Mix shadow with the texture color
    FragColor = texColor * shadowFactor;
}
